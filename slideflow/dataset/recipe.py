"""Builds, loads, and cooks recipes for reproducing Datasets."""

import uuid
import hashlib
import pandas as pd
from typing import Any, Union, List, Optional, Dict, Tuple
from rich.progress import track

import slideflow as sf
from slideflow.util import log
from slideflow.dataset import Dataset

# -----------------------------------------------------------------------------

class Recipe:

    def __init__(
        self,
        name: str,
        description: str,
        uuid: str,
        slides: Union[List[str], Dict[str, Dict[str, Any]], str],
        rois: Optional[Union[List[str], str]] = None,
        extract_tiles_kwargs: Optional[Dict[str, Any]] = None,
        annotations: Optional[str] = None
    ) -> None:
        """Recipe for constructing a Dataset and optionally extracting tiles.

        Args:
            name (str): Human-readable recipe name.
            description (str): Description of the recipe, how it is used, etc.
            uuid (str): Unique numeric identifier, as generated by uuid4().hex
            slides (Union[List[str], List[Dict[str, Any]], str]): Whole slides.
                ``str``: Path to a .tar.gz file with slides, local or remote.
                ``list(str)``: List of slide paths, local or remote.
                ``dict``: Dictionary mapping slide names/identifiers to
                dictionary keyword arguments
            rois (Union[List[str], str]): Regions of interest (CSV files).
                ``str``: Path to .tar.gz file with CSV files, local or remote.
                ``list(str)``: List of individual CSV paths, local or remote.
                Defaults to None.
            extract_tiles_kwargs (Dict[str, Any], optional): Keyword arguments
                for extracting tiles after all slides are loaded. If provided,
                must include ``tile_px`` and ``tile_um`` keys at minimum.
                All other keys are passed to ``Dataset.extract_tiles()``.
                Defaults to None.
            annotations (str, optional): Path to annotations file.
                Defaults to None.
        """
        self.name = name
        self.description = description
        self.uuid = uuid
        self.rois = rois
        self.slides = slides
        self.extract_tiles_kwargs = extract_tiles_kwargs
        self.annotations = annotations

    def __repr__(self):
        r =    "<Recipe("
        r += "\n   name: {!r}".format(self.name)
        r += "\n   description: {!r}".format(self.description)
        r += "\n   uuid: {!r}".format(self.uuid)
        r += "\n   extract_tiles_kwargs: {!r}".format(self.extract_tiles_kwargs)
        r += "\n   annotations: {!r}".format(self.annotations)
        if isinstance(self.slides, str):
            r += "\n   slides: {!r}".format(self.slides)
        else:
            r += "\n   slides: <{} total>".format(len(self.slides))
        if isinstance(self.rois, str):
            r += "\n   rois: {!r}".format(self.rois)
        else:
            r += "\n   rois: <{} total>".format(len(self.rois))
        r += "\n)>"
        return r

    def as_dict(self) -> Dict[str, Any]:
        return {
            'name': self.name,
            'description': self.description,
            'uuid': self.uuid,
            'extract_tiles_kwargs': self.extract_tiles_kwargs,
            'annotations': self.annotations,
            'slides': self.slides,
            'rois': self.rois
        }

    def to_json(self, path: str) -> None:
        sf.util.write_json(self.as_dict(), path)

    def make(self, dest: str) -> None:
        pass

# -----------------------------------------------------------------------------

def _checksum(path: str) -> str:
    """Calculate and return MD5 checksum for file.

    Args:
        path (str): Path to file to verify.

    Returns:
        str: MD5 checksum.
    """
    m = hashlib.md5()
    with open(path, 'rb') as f:
        while chunk := f.read(4096):
            m.update(chunk)
    return m.hexdigest()


def build_local_recipe(
    dataset: Dataset,
    name: str,
    description: str,
    extract_tiles_kwargs: Optional[Dict[str, Any]] = None,
    annotations: Optional[str] = None,
    checksum: bool = True
) -> Recipe:
    """Builds a local recipe from an existing Dataset.

    Args:
        dataset (Dataset, optional): Slideflow Dataset from which to build
            the recipe.
        name (str): Name of the recipe.
        description (str): Description of the recipe.
        extract_tiles_kwargs (dict, optional): Keyword arguments for tile
            extraction. If provided, must contain ``tile_px`` and ``tile_um``
            at minimum. Defaults to None (tiles not extracted).
        annotations (str, optional): Path to annotations file. Defaults to None.
        checksum (bool): Calculate and include checksum

    Returns:
        Recipe
    """
    log.debug(f'Building recipe "{name}"...')

    if checksum:
        slides = {}
        for slide in track(dataset.slide_paths(),
                           description="Calculating checksums..."):
            slides[sf.util.path_to_name(slide)] = {
                'path': slide,
                'md5': _checksum(slide)
            }
    else:
        slides = dataset.slide_paths()  # type: ignore

    return Recipe(
        name=name,
        description=description,
        uuid=uuid.uuid4().hex,
        slides=slides,
        rois=dataset.rois(),
        extract_tiles_kwargs=extract_tiles_kwargs,
        annotations=annotations,
    )


def load_slide_from_path(dest: str, path: str, md5: Optional[str]):
    """Load a slide from a path to a target destination.

    Args:
        dest (str): Destination path to save the slide.
        path (str): Path to slide to load, either local or remote.
        md5 (str, optional): MD5 checksum for slide.

    Returns:
        True if slide loaded successfully, False if the slide failed to load
        or failed the checksum integrity verification.
    """
    raise NotImplementedError


def load_slide_from_tcga(dest: str, tcga_uuid: str, md5: Optional[str]):
    """Download a slide from TCGA using its UUID.

    Args:
        dest (str): Destination path to save the slide.
        path (str): TCGA UUID for the slide.
        md5 (str, optional): MD5 checksum for slide.

    Returns:
        True if slide downloaded successfully, False if the slide failed to
        download or failed the checksum integrity verification.
    """
    raise NotImplementedError


def load_slide(dest: str, **kwargs) -> bool:
    """Load a slide using a given set of keyword arguments."""
    if 'path' in kwargs:
        return load_slide_from_path(dest, **kwargs)
    elif 'tcga_uuid' in kwargs:
        return load_slide_from_tcga(dest, **kwargs)
    else:
        raise ValueError(
            "Unable to determine slide loading method from keyword arguments. "
            "Expected either 'path' or 'tcga_uuid'. Got: {}".format(
                ', '.join(list(kwargs.keys())))
            )


def slide_directory_tree(
    path: str
) -> Tuple[Dict[str, str],
           Optional[Dict[str, List[str]]]]:
    """Recursively search a directory for slides, building a directory tree.

    Args:
        path (str): Directory to search.

    Returns:
        A tuple containing:
            dict: Dictionary mapping slide names to paths for all discovered
            slides, exclusive of duplicate slides.

            dict, optional: Dictionary mapping names of slides with duplicate
            paths, to list containing path to duplicates.
    """
    return dict(), None

def get_tfrdir_path(model_path: str):
    """From a given model path, return the TFR directory containing records 
    used for model training.
    
    Args:
        model_path (str): Path to model directory

    Returns:
        tfr_dir_path (str): Path to TFR directory with TFR used for model training ()

    Ex: "/home/data/TFRECORDS/source_dir/299px_302um"
    
    """

    raise NotImplementedError


def extract_params_from_pdf(pdf_path: str):
    """Extract tile extraction options from tile_extraction.pdf in TFR directory.
    
    Args:
        pdf_path (str): Path to tile_extraction.pdf 

    Returns:
        extraction_details (dict): Dictionary containing options used to extract tiles.
    
    """
    # notes: use PyPDF2 to extract

    raise NotImplementedError

def add_extraction_options_tfrdir(model_path, extraction_details):
    #TODO: slideflow needs to be updated to add these details into params.json when 
    """Use to retroactively add tile extraction details to extraction_options.json 
    in TFR directory.

    Args:
        [[tfr_path]]
        extraction_details

    Returns:
        None (just edits params.json)
    """

    raise NotImplementedError


def extract_tiles():
    # What extract_tiles() function do we want to use & at what level?
    raise NotImplementedError

def purchase_ingredients():
    # maybe add optional args to provide locations of already downloaded items (like annotations)
    """Gather all data ingredients required in recipe (slides, ROIs, annotations). 
    Download from desired locations. [[Also do verified check to confirm everything downloads (like hashing)]].

    Args:
        [[store_addresses: Dictionary of locations/parameters of data sources for recipe. (sort of equivalent to datasets.json)]]
        grocery_list: Dataframe/dict with IDs of data you want to download
    
    
    """
    raise NotImplementedError

def prep_ingredients():
    # Imagine at this step we sort of have the structure like described in datasets.json, that contains all data required to prep dataset for training.
    # Using slide locations +/- ROIs, plus extraction parameters, extract tiles (by calling one of the existing extract_tiles functions). 
    # We need to provide optional arguments to provide to extract_tiles to decide if tiles should be saved or not.
    # Create project directory. 
    '''
    
    Args:
        Format: "tfrecords", "tiles", "both" (or have a save tiles step like in regular tile extraction)

    '''
    raise NotImplementedError


#TODO: Answer question: do we want to have ingredients class? 


def wrapped_extract_tiles():
    # check step to verify that everything looks gucci prior to extracting tiles, offer possibility of making slight edits to params
    # i.e. step to assert that options from extraction details still match to currently implemented slideflow keyword args. 
    raise NotImplementedError

